<HTML>
<HEAD>
<TITLE>Datentypen in C#</TITLE>
<META HTTP-EQUIV="content-type: text/html; charset= ISO-8859-1">
<META HTTP-EQUIV="Content-Language" CONTENT="DE">
<META NAME="robots" CONTENT="FOLLOW,INDEX">
<META NAME="generator" CONTENT="Xitra Site Publishing">
<meta name="Author" content="webmaster@aspheute.com">

<META NAME="revisit-after" CONTENT="21 days">
<META NAME="copyright" CONTENT="(c) 2000-2006. Alle Rechte vorbehalten. Der Inhalt dieser Seiten ist urheberrechtlich geschützt.">
<META HTTP-EQUIV="expires" CONTENT="1999-03-30T00:00:00+00:00"> 
<META HTTP-EQUIV="Pragma" CONTENT="no-cache">
<META HTTP-EQUIV="Cache-Control" CONTENT="no-store">

<meta http-equiv="Description" name="Description" content="In diesem Artikel m&ouml;chte ich Ihnen die Datentypen von C# (sprich "C sharp") erkl&auml;ren. Dies ist zugegebenerma&szlig;en eines der trocken Kapitel aus der C#-Programmierung...">
<meta http-equiv="Keywords" name="Keywords" content="ASP,Active Server Pages,IIS,Internet Information Server,PWS,Personal Web Server,ADO,C#,Datentypen,NGWS,.NET,.NET Framework,framework,int,long,string,array,interface,class,boxing,unboxing">
<link rel="stylesheet" href="../includes/default.css">
</HEAD>
<BODY BGCOLOR="#ffffff" >


<div style="border-bottom: solid 5px white;">
<div class="DotNetGermanCommunityBar">
    <a href="http://www.glengamoi.com">Glengamoi (Forum)</a> &middot;
    <a href="http://www.aspheute.com/" style="font-weight: bold">AspHeute</a> &middot;
    <a href="http://dotnetheute.com/">.NET Heute (RSS-Suche)</a> &middot;
    <a href="http://aspxfiles.com/">AspxFiles (Wiki)</a> &middot;
    <a href="http://blogs.dotnetgerman.com/">.NET Blogs</a>
</div>
</div>


<H1>Datentypen in C#</H1>
<p>
Geschrieben von: <a href="../autoren/christianholm.htm">Christian Holm</a><br>
Kategorie: <a href="../kategorien/Csharp.htm">C#</a><br>
<SCRIPT src="/service/artikelbewertung.asp?Artikel=20000726"></SCRIPT>
</p>


<p><strong>This printed page brought to you by <a href="http://www.alphasierrapapa.com/">AlphaSierraPapa</a></strong></p><p>
In diesem Artikel m&ouml;chte ich Ihnen die Datentypen von C# (sprich "C sharp") erkl&auml;ren. Obwohl C# mit 
C++ verwandt ist, hat sich auch einiges in der Definition und in der Behandlung der Datentypen 
ge&auml;ndert. 
So einfach sich dieses Thema vielleicht auch anh&ouml;ren mag, Datentypen stellen unter anderem die 
Grundstruktur eines Programmes dar, und k&ouml;nnen bei falscher Implementation zu &auml;rgerlichen 
Compilerfehlern f&uuml;hren.
</p>
<p>
<b>Anmerkung:</b> Dadurch da&szlig; in C#, wie auch in C++, der Sourcecode in Englisch gehalten ist, werde 
ich die sprachspezifischen Befehle, Schl&uuml;sselw&ouml;rter etc., unver&auml;ndert lassen und gegebenfalls das 
deutsche &Auml;quivalent verwenden; z.B. floating point- / Flie&szlig;komma-.
</p>


<h2>Einteilung der Datentypen</h2>
<p>
Grunds&auml;tzlich lassen sich die Datentypen wie folgt in drei Kategorien einteilen:
<ul>
	<li><i>value-type</i>
	<li><i>reference-type</i>
	<li><i>pointer-type</i>
</ul>
</p>

<p>
<b>Anmerkung zu &quot;pointer-types&quot;:</b>
Diese Typen k&ouml;nnen <i>nur</i> im sogenannten Unsafe Code verwendet werden. Pointer (Zeiger)
beinhalten Adressen zu Speicherorten. Da in dieser Hinsicht in C# Vereinfachungen f&uuml;r den Entwickler
getroffen wurden (u. a. der Garbage Collector, kurz GC, der nun die Speicherverwaltung &uuml;ber hat) 
sollten 
diese nur mehr eingeschr&auml;nkt verwendet werden, um Kollisionen mit gesch&uuml;tztem Speicherbereich oder 
"Exception Errors" zu vermeiden.
</p>
<p>Der Unterschied zwischen value-types und reference-types liegt darin, da&szlig; value-types die 
tats&auml;chlichen Daten
enthalten und reference-types einen Bezug auf die Daten beinhalten.<br>
Mit den reference-types ist es z.B. m&ouml;glich, da&szlig; zwei Variablen sich auf ein und dasselbe Objekt beziehen. 
Damit ist man in der Lage das Objekt mit der einen Variable manipulieren, w&auml;hrend die &Auml;nderung in 
beiden Variablen sichtbar ist.
</p>
<p>
Da jeder value-type eine eigene Kopie der Daten besitzt, k&ouml;nnen Manipulationen an der einen Variable  
die andere nicht beeinflu&szlig;en.</p>
<p>

<h3>Value-Types</h3>
<p>
Dieser Datentyp ist entweder ein <i>struct</i>-Typ oder ein <i>enumeration</i>-Typ. C# enth&auml;lt 
vordefinierte struct-types welche auch <i>simple-types</i> genannt werden. 
Eine Variable enth&auml;lt immer einen Wert im Datentyp der ihr zugewiesen wurde. Bevor Sie in C# eine 
Variable verwenden k&ouml;nnen, m&uuml;ssen Sie diese zwingend vorher deklarieren.
</p>
<p>
In C# werden die Variablen-Typen nun eingeteilt in:
<ul>	
	<li><i>simple-types</i>
	<li><i>struct-types</i> 
	<li><i>enumeration-types</i>
</ul>
</p>
<p>
Besprechen wir nun die <i>simple-types</i>:
Diese unterteilen sich in 
<ul>
	<li><i>integral-types</i> (Integer Datentyp)
	<li><i>decimal-types</i> 
	<li><i>floating point-types</i> (Flie&szlig;komma Datentyp) 
	<li><i>bool-types</i>
	<li><i>char-type</i>
</ul>
</p>
<p><b>Die wichtigsten Datentypen seien hier ausf&uuml;hrlicher beschrieben:</b></p>

<h4><i>Integral Types</i></h4>

<p>In C# gibt es neun integral-types: byte, sbyte, short, ushort, int, uint, long und ulong. Der Typ char 
soll sp&auml;ter extra beschrieben werden. Die aufgez&auml;hlten Datentypen haben folgende Eigenschaften:</p>
<p>
<table cellspacing="5" cellpadding="2" border="1">
<tr>
    <td>Daten-Typ</td>
    <td>G&uuml;ltigkeitsbereich</td>
    <td>Bitgr&ouml;&szlig;e</td>
</tr>
<tr>
    <td>byte</td>
    <td>0 bis 255</td>
    <td>Unsigned 8-bit integer </td>
</tr>
<tr>
    <td>sbyte</td>
    <td>-128 bis 127</td>
    <td>Signed 8-bit Integer</td>
</tr>
<tr>
    <td>short</td>   
    <td>-32.768 bis 32.767</td>
    <td>Signed 16-bit Integer</td>
</tr>
<tr>
    <td>ushort</td>
    <td>0 bis 65.535</td>
    <td>Unsigned 16-bit Integer</td>
</tr>
<tr>
    <td>int</td>
    <td>-2.147.483.648 bis 2.147.483.647</td>
    <td>Signed 32-bit Integer</td>
</tr>
<tr>
    <td>uint</td>
    <td>0 bis 4.294.967.295</td>
    <td>Unsigned 32-bit Integer</td>
</tr>
<tr>
    <td>long</td>
    <td>&#150;9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807</td>
    <td>Signed 64-bit Integer</td>
</tr>
<tr>
    <td>ulong</td>
    <td>0 bis 18.446.744.073.709.551.615</td>
    <td>Unsigned 64-bit Integer</td>
</tr>
<tr>
    <td>char</td>
    <td>U+0000 bis U+ffff</td>
    <td>Unicode 16-bit Zeichen</td>
</tr>
</table>
</p>

<p><b>Beachte:</b>
Wie Ihnen sicher schon aufgefallen ist, haben <i>integer</i> und <i>long</i> andere
G&uuml;ltigkeitsbereiche als in C++. 
In C# ist <i>integer</i> nicht mehr von einem <i>word</i> abh&auml;ngig und <i>long</i> hat jetzt eine 
Bitgr&ouml;&szlig;e von 64 bit.
</p>

<h4><i>Decimal Type</i></h4>

<p>Der Decimal Datentyp hat eine Gr&ouml;&szlig;e von 128 Bit. Er weist also eine hohe Genauigkeit gegen&uuml;ber dem 
floating point-type auf, hat aber im Vergleich zum floating point-type einen engeren 
G&uuml;ltigkeitsbereich. Dieser Datentyp ist dienlich f&uuml;r finanzmathematische Berechungen oder 
W&auml;hrungsumrechungen. Der G&uuml;ltigkeitsbereich geht von 1,0 * 10^-28 bis 7,9 * 10^28 mit 28-29 
signifikanten Stellen. </p>

<p><b>Beachte:</b> Die Genauigkeit ist in signifikanten Stellen gegeben und nicht in Dezimalstellen. </p>

<p>Rechenoperationen sind bis zu 28 Dezimalstellen genau. Auf Grund der besprochenen Unterschiede zwischen 
decimal und floating-point sollten sie auch vorsichtig beim umcasten (umwandeln) in die anderen Typen sein. Denn in 
die eine Richtung generieren sie m&ouml;glicherweise einen &Uuml;berlauf, in die andere verlieren Sie die 
Genauigkeit.</p>

<p>Bei der Variablendeklaration ist folgendes zu beachten:
Wenn Sie bei <i>decimal</i> Kommastellen benutzen wollen, so m&uuml;ssen Sie das mit einem <i>m</i> als 
Suffix angeben.</p>

<p>
Beispiel: decimal Wert = 3.4m; (Im C# Source Code gilt: Im Englischen gilt der Punkt als Komma!)
Falls Sie den Suffix nicht angeben, wird die Variable vom Compiler als <i>double</i> behandelt
</p>


<h4><i>floating point Types</i></h4>

<p>Es gibt hierbei zwei unterschiedliche Typen <i>float</i> und <i>double</i>. Wie nicht anders 
zu erwarten unterscheiden sie sich im G&uuml;ltigkeitsbereich und in der Genauigkeit.</p>
<p>
<table cellspacing="5" cellpadding="2" border="1">
<tr>
    <td>Daten-Typ</td>
    <td>G&uuml;ltigkeitsbereich</td>
    <td>Genauigkeit</td>
</tr>
<tr>
    <td>float</td>
    <td>1.5*10^-45 bis 3.4*10^38</td>
    <td>7 stellig</td>
</tr>
<tr>
    <td>double</td>
    <td>5*10^-324 bis 1.7*10^308</td>
    <td>15 bis 16 stellig</td>
</tr>
</table>
</p>


<h4><i>bool Type</i></h4>

<p>Dieser verdient in C# Beachtung: im Gegensatz zu C++ sind boolsche Datentypen und 
Integer Datentypen nicht mehr ident! Das hei&szlig;t, der boolsche Datentyp umfa&szlig;t <b>nur</b> mehr die Werte 
<i>true</i> oder <i>false</i>, und nicht mehr Null (0) oder einen von Null (0) ungleichen Wert.
</p>

<h4><i>char Type</i></h4>

<p>Dieser Datentyp stellt ein Zeichen im Unicodeformat dar. Ein Unicodezeichen hat eine Gr&ouml;&szlig;e von 16 bit 
und ist f&uuml;r die meisten Sprachen verwendbar. Um einer char-Variablen einen Wert zuzuweisen, geht man 
so vor, da&szlig; man den Buchstaben mit einfachen Anf&uuml;hrungszeichen umgibt.
</p>
<p>
In C# sieht dies dann so aus:
<pre style="background='silver';">
<i>char Variablenname = 'Unicode Zeichen';</i>  // z.B char zeichen='C';
</pre>
</p>
<p>Zwei weitere Darstellungsm&ouml;glichkeiten f&uuml;r Unicode Zeichen sollen hier nur am Rande erw&auml;hnt 
werden - die M&ouml;glichkeit der 
<ul>
<li>hexadezimalen Escape-Sequenz mittles Pr&auml;fix "\x" <br>z.B.: char zeichen = '\x<i>EscSequenz</i>';
<li>Unicodeersatzzeichen mittles Pr&auml;fix "\u"<br>z.B.: char zeichen = '\u<i>UnicodeSequenz</i>';
</ul>
</p>

<p><b>Beachte:</b> Wenn Sie den <i>char</i> Datentyp umcasten wollen, m&uuml;ssen Sie das auch explizit tun (im 
Gegensatz zu C++), indem sie eine extra Anweisung schreiben.</p>

<h4><i>struct Type</i></h4>

<p>Ein struct Datentyp kann Konstanten, Felder, Methoden, Eigenschaften, Indexer, etc. deklarieren. Anders 
als in C++ werden in C# structs als Wert aufgefa&szlig;t und Klassen als Referenztyp. Der Grundgedanke bei 
der Verwendung von struct ist, da&szlig; man damit "Objekte" erstellt, die wesentlich weniger Speicherplatz 
als echte Objekte ben&ouml;tigen. Das kommt dadurch, da&szlig; keine zus&auml;tzliche Speicherreferenzen ben&ouml;tigt 
werden wie f&uuml;r Klassen.</p>

<h4><i>enumeration Type</i></h4>
<p>
Wenn Sie einen spezielle Datentyp suchen, der eine Reihe von vordefinierten Konstanten enthalten kann, dann 
sollten Sie den Datentyp enumeration verwenden. Jeder enumeration-type hat seinen untergeordenten 
Datentyp (z.B. byte, short, integer oder long).
</p>

<p>Beispiel: <i>enum Variablenname {Menge};</i></p>

<p>
<pre style="background='silver';">
enum Woche {Montag, Dienstag, Mittwoch, Donnerstag, Freitag, 
	Samstag, Sonntag};
</pre>
</p>			

<p>
Sie k&ouml;nnen nat&uuml;rlich auch in der Mengenangabe einen anderen Datentyp angeben:
</p>
<p>
Beispiel: <i>enum Variablenname : Datentyp {Menge};</i>
</p>
<p>enum Woche : byte {Montag, Dienstag, Mittwoch, Donnerstag, Freitag, Samstag, Sonntag};</p>


<h3>Reference Types</h3>
<p>
Ein reference-type kann eine Klasse, ein interface-type oder ein Array sein. Ein reference-type ist 
die Refernz zu einer Instanz, und damit letzlich zu einem Objekt.
Der Wert <i>null</i> ist kompatibel mit allen Reference types und bedeutet die Nonexistenz einer 
Instanz.
</p>

<p>Der reference-type gliedert sich in folgende Untertypen:
<ul>
<li>Interface types</li>
<li>Class types</li>
<li>Delegate types</li>
<li>Array types</li>
<li>Object type</li>
<li>String type</li>
</ul>
</p>

<h4>Class types</h4>
<p>
Der Class type definiert eine Datenstruktur welche Daten-Member (Konstanten, Felder und 
Events) und Funktions-Member (Methoden, Eigenschaften, Indexer, Operatoren, Konstruktoren und 
Destruktoren) beeinhaltet. Class types unterst&uuml;tzen Vererbung; das bedeutet, da&szlig; hergeleitete 
Classes die Base Class erweitern und spezialisieren k&ouml;nnen.
</p>
	
<h4>Delegate types</h4>
<p>
Ein delegate ist ein Referenztyp der sich auf eine Methode oder auf eine Objektinstanz 
und die Instanzmethode dieses Objektes bezieht. Der n&auml;chste Verwandte zum delegate in C oder C++ ist der 
Funktionspointer (addressof in VB), wobei ein Funktionspointer nur statische Funktionen referenziert, der delegate jedoch 
statische und Instanzmethoden. Der delegate speichert nicht nur den Methodenanfangspunkt sondern auch 
eine Referenz zum Instanzobjekt um die Methode aufzurufen.
</p>

<h4>Array types</h4>
<p>
Ein Array ist eine Datenstruktur welche eine Anzahl von Variablen beeinhaltet die durch 
berechnete Indizes zug&auml;nglich ist. Die Variablen die sich in einem Array befinden, werden auch als 
Elemente eines Arrays bezeichnet und sind alle vom selben Typ. Dieser Typ wird als "Elementtyp des 
Arrays" bezeichnet. Mehr Informationen zu Arrays erhalten Sie in einem unserer n&auml;chsten Artikel.
</p>

<h4>Object type</h4>
<p>
Der Object Type ist die ultimative Base class aller anderen Typen. Jeder Typ in C# l&auml;&szlig;t 
sich direkt oder indirekt vom Object Type herleiten.
Das <i>object</i> Schl&uuml;sselwort ist einfach nur ein angenommener(anderer) Name f&uuml;r die vordefinierte 
<i>System.Object</i> Klasse. Das Keyword object ist genau das gleiche wie System.Object und umgekehrt.
</p>

<h4>String type</h4>
<p>
Der String type ist ein abgeschlossener Class type welcher direkt von Object abgeleitet ist. 
Instanzen der String Class repr&auml;sentieren Unicode Zeichenfolgen. Das <i>string</i> keyword ist einfach nur 
ein anderer Name f&uuml;r die vordefinierte <i>System.String</i> Class. Der Keyword <i>string</i> ist genau das selbe wie 
<i>System.String</i> und umgekehrt.
</p>

<h4>Interfaces</h4>
<p>
Ein Interface definiert einen Referenztyp der nur abstrakte Members (Mitglieder) hat. Ein interface wird 
dazu verwendet, um eine Schnittstellen-Vereinbarung zu schaffen. Eine Klasse oder ein struct, welches ein Interface 
implementiert, mu&szlig; die Vereinbarung einhalten. Ein interface kann Methoden, Eigenschaften oder Indexer 
enthalten.
</p>

<h3>Boxing und Unboxing</h3>	
<p>
Boxing und Unboxing ist ein zentraler Teil im Type-System von C# (und der Runtime). Es stellt ein Bindeglied zwischen 
value-types und reference-types zur Verf&uuml;gung. Value-types haben den Vorteil, da&szlig; sie wenig Speicherplatz 
ben&ouml;tigen. In manchen F&auml;llen ist es jedoch von Vorteil, da&szlig; value-types auch die die Eigenschaften von 
Objekten haben. Diese &Uuml;bereinkunft macht den Hauptteil von C# aus, da&szlig; die Verkn&uuml;pfung zwischen 
value-types und reference-types dadurch geschieht, da&szlig; ein value-type aus einem und in ein Objekt 
ungewandelt werden kann. Unter dem Motto "Es ist zwar alles ein Objekt, aber nur dann wenn es eines sein 
mu&szlig;."
</p>

<h4><b>Boxing Vorgang</b></h4>
<p>
Der Boxing Vorgang beschreibt die Umwandlung von einem value-type zu einem Objekt. 
Bei dem Boxing Vorgang wird die Instanz eines Objekts erstellt und der urspr&uuml;ngliche 
Wert des value-types wird in das neue Objekt kopiert.
</p>
<p>Ein Beispiel:
<pre style="background='silver';">
...
int nVariable = 1; 
object oVariable = nVariable;
...
</pre>
</p>
<p>
Hier geschieht folgendes: in der ersten Sourcecodezeile wird die Variable "nVariable" als integer 
Datentyp deklariert, und diese bekommt zus&auml;tzlich den Wert 1 zugewiesen. In der zweiten Zeile wird nun 
eine neue Instanz for das Objekt oVariable erstellt und ihr der Wert der Variable <i>nVariable</i> zugewiesen. 
Durch diesen Kopiervorgang erhalte ich 2 v&ouml;llig unabh&auml;ngige Variablen.
Das hei&szlig;t, wenn der Wert des Objekts oVariable ge&auml;ndert wird, dann hat sich der Wert von 
nVariable <b>nicht</b> &auml;ndert.
</p>
<p>Die folgende kleine Anweisung beweist dies:
<pre style="background='silver';">
int nVariable = 1;
object oVariable = nVariable;
oVariable = 2;
Console.WriteLine("{0} {1}", nVariable, oVariable);
</pre>
</p>
<p>
Die Werte, die ausgegeben werden sind einmal 1, und das zweite mal 2.
</p>

<h4><b>Unboxing Vorgang</b></h4>
<p>
Man k&ouml;nnte sagen, dies sei der umgekehrte Vorgang. Beim Unboxing Vorgang wird ein
value type aus einem Objekt extrahiert. Der C# Compiler &uuml;berpr&uuml;ft zus&auml;tzlich, ob die von Ihnen 
angeforderte Variable, welche Sie aus dem Objekt extrahieren wollen, tats&auml;chlich den angeforderten
unboxed Type entsprechen kann.
</p>
<p>Ein Beispiel:
<pre style="background='silver';">
...
int nVariable = 1;
object oVariable = nVariable;
int nUBVariable = (int)oVariable;
...
</pre>
</p>
<p>
W&uuml;rde hier ein anderer Typ als <i>int</i> f&uuml;r die Unboxing Operation angefordert, bek&auml;me man eine Exception.
</p>

<h2>Schlu&szlig;bemerkung</h2>
<p>
Dies ist zugegebenerma&szlig;en eines der trocken Kapitel aus der C#-Programmierung.
In diesem Artikel habe ich versucht Ihnen die verschieden Datentypen vorzustellen und das umcasten von 
Variablen zu Objekten (boxing) und umgekehrt (unboxing).  Obwohl C# einige, f&uuml;r den Programmierer vereinfachende Funktionen und 
Dienstleistungen zur Verf&uuml;gung stellt, ist der richtige Umgang mit Datentypen von grundlegender 
Bedeutung.
</p>

<p><strong>This printed page brought to you by <a href="http://www.alphasierrapapa.com/">AlphaSierraPapa</a></strong></p><h2>Verwandte Artikel</h2>
<p>
<a href="../artikel/20000713.htm">A Brief History of C#</a><br>
<SPAN class="content">http:/www.aspheute.com/artikel/20000713.htm</span><br>
<a href="../artikel/20020507.htm">Deutsche Personalausweisnummern verifizieren</a><br>
<SPAN class="content">http:/www.aspheute.com/artikel/20020507.htm</span><br>
<a href="../artikel/20000823.htm">Die Hashtable Klasse</a><br>
<SPAN class="content">http:/www.aspheute.com/artikel/20000823.htm</span><br>
<a href="../artikel/20010215.htm">Enums lesbar machen</a><br>
<SPAN class="content">http:/www.aspheute.com/artikel/20010215.htm</span><br>
<a href="../artikel/20020705.htm">Formularbasierte Authentifizierung in f&uuml;nf Minuten</a><br>
<SPAN class="content">http:/www.aspheute.com/artikel/20020705.htm</span><br>
<a href="../artikel/20020207.htm">Unions in C#</a><br>
<SPAN class="content">http:/www.aspheute.com/artikel/20020207.htm</span><br>
<a href="../artikel/20020125.htm">Variable Parameterlisten in Funktionen</a><br>
<SPAN class="content">http:/www.aspheute.com/artikel/20020125.htm</span><br>
<a href="../artikel/20000731.htm">Verwendung von Arrays in C#</a><br>
<SPAN class="content">http:/www.aspheute.com/artikel/20000731.htm</span><br>
<a href="../artikel/20010621.htm">Web Services 101 in ASP.NET</a><br>
<SPAN class="content">http:/www.aspheute.com/artikel/20010621.htm</span><br>
<a href="../artikel/20010802.htm">Web.Config 101</a><br>
<SPAN class="content">http:/www.aspheute.com/artikel/20010802.htm</span><br>
<a href="../artikel/20020905.htm">Wochenberechnung mit .NET</a><br>
<SPAN class="content">http:/www.aspheute.com/artikel/20020905.htm</span><br>

</p>

&nbsp;<P>
<center>

</center>

<center>
<p class="content">
&copy;2000-2006 <A HREF="../service/copyright.htm" title="Copyright Informationen">AspHeute.com</A><br>
Alle Rechte vorbehalten. Der Inhalt dieser Seiten ist urheberrechtlich gesch&uuml;tzt.<br>
Eine &Uuml;bernahme von Texten (auch nur auszugsweise) oder Graphiken bedarf unserer schriftlichen Zustimmung.
<hr>
</p>
</center>

</td>
</tr><!--Tabelle aussen, 2/2-->
</table><!--Tabelle aussen-->
</div>

</BODY>
</HTML>
