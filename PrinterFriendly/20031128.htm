<HTML>
<HEAD>
<TITLE>Die ersten Schritte in Visual Basic .NET</TITLE>
<META HTTP-EQUIV="content-type: text/html; charset= ISO-8859-1">
<META HTTP-EQUIV="Content-Language" CONTENT="DE">
<META NAME="robots" CONTENT="FOLLOW,INDEX">
<META NAME="generator" CONTENT="Xitra Site Publishing">
<meta name="Author" content="webmaster@aspheute.com">

<META NAME="revisit-after" CONTENT="21 days">
<META NAME="copyright" CONTENT="(c) 2000-2006. Alle Rechte vorbehalten. Der Inhalt dieser Seiten ist urheberrechtlich geschützt.">
<META HTTP-EQUIV="expires" CONTENT="1999-03-30T00:00:00+00:00"> 
<META HTTP-EQUIV="Pragma" CONTENT="no-cache">
<META HTTP-EQUIV="Cache-Control" CONTENT="no-store">

<meta http-equiv="Description" name="Description" content="Programmiersprachen gibt es ja viele - alle mit unterschiedlichen Anwendungsbereichen und Erfordernissen. Eine Sprache sticht jedoch hervor - Visual Basic. Die Lernkurve ist relativ niedrig und man kann auch aufwendigere Projekte damit realisieren.">
<meta http-equiv="Keywords" name="Keywords" content="ASP,Active Server Pages,IIS,Internet Information Server,PWS,Personal Web Server,ADO,VB.NET,Intro,Einführung,Introduction,Tutorial,Hilfe,Einsteiger,Lernen,101,Erste Schritte,Anfänger,Beginner,Neueinstieg">
<link rel="stylesheet" href="../includes/default.css">
</HEAD>
<BODY BGCOLOR="#ffffff" >


<div style="border-bottom: solid 5px white;">
<div class="DotNetGermanCommunityBar">
    <a href="http://www.glengamoi.com">Glengamoi (Forum)</a> &middot;
    <a href="http://www.aspheute.com/" style="font-weight: bold">AspHeute</a> &middot;
    <a href="http://dotnetheute.com/">.NET Heute (RSS-Suche)</a> &middot;
    <a href="http://aspxfiles.com/">AspxFiles (Wiki)</a> &middot;
    <a href="http://blogs.dotnetgerman.com/">.NET Blogs</a>
</div>
</div>


<H1>Die ersten Schritte in Visual Basic .NET</H1>
<p>
Geschrieben von: <a href="../autoren/christianholm.htm">Christian Holm</a><br>
Kategorie: <a href="../kategorien/VBdotNET.htm">VB.NET</a><br>
<SCRIPT src="/service/artikelbewertung.asp?Artikel=20031128"></SCRIPT>
</p>


<p><strong>This printed page brought to you by <a href="http://www.alphasierrapapa.com/">AlphaSierraPapa</a></strong></p><p>
Programmiersprachen gibt es ja viele - alle mit unterschiedlichen Anwendungsbereichen und Erfordernissen. Je komplexer
aber die Aufgabenstellung wird, desto gr&ouml;&szlig;er wird aber auch die Anforderung an den Programmierer. Eine Sprache sticht jedoch
hervor - Visual Basic. Die Lernkurve ist relativ niedrig und man kann auch aufwendigere Projekte damit realisieren.
Visual Basic .NET geht nun noch um einiges weiter. Diese Artikelserie soll Ihnen einen Einstieg in diese .NET Sprache geben.  
</p>

<p>
Visual Basic wird oft in der Programmierergemeinde bel&auml;chelt. Dies beginnt beim Arrayindex (Datenfeldindex) und bei der
umfangreicheren Syntax bis zur eingeschr&auml;nkten Objektorientiertheit. Mit Visual Basic .NET (VB .NET) mu&szlig; der Programmierer 
im Vergleich zu anderen Programmiersprachen jedoch keine Kompromisse mehr eingehen. Im Bereich der meist verwendeten 
objektorientierten Programmiersprachen steht VB .NET den anderen um nichts nach. Sie k&ouml;nnen mit nahezu selbsterkl&auml;rendem
Syntax professionelle und performante Anwendungen erstellen wie in C# (sprich C Sharp) oder Managed C++.  
</p>

<p>
Mit dem .NET Framework als Grundlage haben Sie uneingeschr&auml;nkten Zugriff auf die .NET Base Class Library (BCL), die Ihnen
das Erstellen von Windows-Applikationen wesentlich erleichtert und da alle .NET Sprachen auf die gleiche Codebasis
(MSIL, Microsoft Intermediate Language) kompilieren, haben Sie auch keine Geschwindigkeitseinbu&szlig;en bei der Ausf&uuml;hrung 
des Programmes. Ein
weiterer Vorteil von .NET allgemein ist auch, da&szlig; Sie nun ohne Wrapper auf andere .NET Assemblies (z.B. Programmbibliotheken, DLLs)
zugreifen bzw. diese verwenden k&ouml;nnen. So k&ouml;nnen Sie etwa die Funktionalit&auml;t einer in C# oder Managed C++ geschriebenen DLL
nutzen oder dieser auch Features zur Verf&uuml;gung stellen. Da selbst das aktuelle Windows Client-Betriebssystem 
im Moment nicht viel mit VB .NET Syntax anfangen kann, sind einige Anforderungen zu erf&uuml;llen.
</p>

<p>
Damit wir den geschrieben Sourcecode kompilieren k&ouml;nnen und die Funktionen der BCL nutzen k&ouml;nnen ben&ouml;tigen wir
das .NET Framework. Da Sie ja nun in Zukunft vern&uuml;nftig Arbeiten und Freude dabei haben wollen, ben&ouml;tigen
Sie das 
<a href="http://www.dotnetgerman.com/links/dl_dotnetsdk.asp" target="_blank">.NET Framework Software Development Kit (SDK)</a>
, welches Sie kostenlos downloaden k&ouml;nnen. Das SDK enth&auml;lt den notwendigen Visual Basic .NET Kompiler (vbc.exe)
und eine vern&uuml;nftige und umfangreiche Dokumentation (auch in Deutsch erh&auml;ltlich), die Ihnen alles von Kompilerfehlermeldungen bis zu den Features
der BCL leicht verst&auml;ndlich erkl&auml;rt. Erg&auml;nzt wird die Dokumentation mit vielen Anwendungsbeispielen die Ihnen die
einzelnen Funktionen veranschaulichen.
</p>

<p>
F&uuml;r diese Artikelserie nicht erforderlich, aber f&uuml;r die sp&auml;tere Arbeit empfohlen, ist die Verwendung einer Integrierten
Entwicklungs Umgebung (IDE). Im Vergleich zu "trivialen" Editoren, die lediglich Syntaxhighlighting und die 
Einbindung des Kompilers bieten, haben IDEs Features wie Code-Completion (automatische Erg&auml;nzung von Syntax), Projektmanagement
(wettbewerbsf&auml;hige Anwendungen bestehen aus mehr als einer Quelldatei!) oder eine integrierte Anbindung f&uuml;r Versionskontroll-Applikationen
(CVS, Concurrent Versions System) um nur einige wenige zu nennen. Je nach Projektumfang und Budget kann man sich
kostenlosen IDEs (z.B. <a href="http://www.icsharpcode.net/OpenSource/SD/" target="_blank">SharpDevelop</a>) oder
k&auml;uflichen IDEs (z.B. <a href="http://msdn.microsoft.com/vstudio/" target="_blank">Visual Studio .NET Editionen</a>) bedienen.
Nach dem Installieren dieser Voraussetzungen kann das Programmieren beginnen! Sehen wir uns also das erste einfache Beispiel
an.
</p>


<h2>Das erste VB .NET Programm</h2>

<p>
Wie gesagt, der einzige Unterschied bleibt im etwas l&auml;ngeren Syntax. Und diesen wollen wir uns in weiterer Folge ansehen.
Beginnen wir mit einem einfachen Beispiel. Dies ist f&uuml;r gew&ouml;hnlich die Ausgabe von "Hello World" an die Konsole. Nicht 
besonders aufregend, aber ein einfacher Einstieg in eine neue Welt. Bevor wir mit dem Schreiben des Sourcecodes beginnen, ist es ratsam
sich vorher zu &uuml;berlegen was man alles ben&ouml;tigt, quasi eine "Einkaufsliste" zu erstellen, um eine L&ouml;sung zu kreieren. 
</p>

<p>
Wir wollen zudem auch objektorientiert programmieren, da diese Programmierweise viele Vorteile bietet und den Sourcecode modularer
und strukturierter gestaltet. Ohne jetzt in staubiger Theorie zu versinken, seien hier nur die hier
ben&ouml;tigten Begriffe "Klasse - Objekt" kurz erkl&auml;rt. Diese beiden Begriffe stehen in einem engen Zusammenhang. 
Einfach ausgedr&uuml;ckt geht es in objektorientierter Programmierung darum, da&szlig; Objekte mit miteinander kommunizieren
bzw. Daten austauschen. Objekte existieren w&auml;hrend der Laufzeit eines Programmes im fl&uuml;chtigen Speicher (RAM).
Diese Objekte haben Eigenschaften die im weiteren Sinne die Funktionalit&auml;t Ihres Programmes darstellen.
</p>

<p>
Diese Eigenschaften werden vom Programmierer definiert. Diese Definitionen werden von den Klassen repr&auml;sentiert.
Sie sind also die "Blaupausen" der Objekte. So k&ouml;nnte man sich zum Beispiel eine Klasse als DNS f&uuml;r ein S&auml;ugetier
vorstellen und ein Objekt als die nach den definierten Eigenschaften in der DNS kreierte Lebensform. Je nach Definition
der Eigenschaften wird ein Tier, Mensch, etc. erstellt. Diese Lebewesen k&ouml;nnen nach gewissen Richtlinien miteinander 
"kommunizieren" - so auch die Objekte des Programmierers.
</p>

<p>
In unserem einfachen Konsolen-Beispiel wollen wir aber nur ein Objekt erstellen. Dieses Objekt hat die Eigenschaft
bzw. Funktion Text ("Hello World") auf der Kommandozeile anzuzeigen. Das h&ouml;rt sich einfach an, ben&ouml;tigt aber einiges
Voraussetzungen um es zu realisieren, da VB .NET selbst ja nur die "Grammatik" zur Verf&uuml;gung stellt, aber keine direkten 
Werkzeuge.
</p>

<p>
Da uns in den meisten F&auml;llen egal ist, wie tats&auml;chlich der Text in der Konsole aufscheint, nehmen wir die BCL
zur Hilfe, die uns diese Funktionalit&auml;t zur Verf&uuml;gung stellt. Unsere "Einkaufsliste" ist nun hiermit vollst&auml;ndig:
Wir brauchen eine Klasse und die Funktionalit&auml;t Text in der Konsole anzuzeigen. Schreiten wir ans Werk!
</p>

<p>
Da der VB Syntax relativ selbsterk&auml;rend ist, ist es auch nicht anders bei der Klassendefinition, unserer Blaupause
(einer Klasse namens "MainApp") f&uuml;r das zuk&uuml;nftige Objekt:
</p>

<pre style="background='silver';">
Class MainApp 
...
End Class
</pre>

<p>
Wie erw&auml;hnt erfordern objektorientierte Programme eine Struktur, sprich eine Ordnung in den (vielen) Codezeilen. Um eine klar 
definierte Struktur zu erhalten, mu&szlig; man dem Kompiler signalisieren, wo ein Anweisungsblock beginnt und wo
er endet. Da es in Visual Basic keine geschwungenen Klammern als Begrenzer wie in C# oder C++ gibt, schreibt man z.B.
f&uuml;r eine Klasse als Anfang <b>Class</b> und als Ende <b>End Class</b>. Was jetzt f&uuml;r unser Programm noch
fehlt ist seine Funktionalit&auml;t, also etwas zu "tun". Dieses "tun" wird in Form von Methoden abgebildet. Hier, im
einfachsten Falle, verwenden wir eine "Sub Prozedur" die die Aufgabe erledigen wird. Diese "Sub Prozedur" ist
hier zus&auml;tzlich noch etwas besonderes! Sie ist der Einsprungpunkt unseres Programms, d.h. wenn unser Programm
l&auml;uft, soll diese Methode als erstes ausgef&uuml;hrt werden. Der Einsprungpunkt regelt somit den Ablauf eines Programms.
</p>

<p>
Daher m&uuml;ssen wir ihr auch den Namen "Main" geben, weil diese spezielle Methode eine vordefinierte Signatur haben mu&szlig; um
als Einsprungspunkt vom Kompiler erkannt zu werden. Eine Funktionalit&auml;t erhalten wir dadurch noch nicht. Diese ist aber nun an der
Reihe. Die Funktionalit&auml;t des Anzeigens von Text in der Kommandozeile ist in der <b>Console</b>-Klasse der BCL enthalten:
Die <b>WriteLine</b>-Methode. Methoden k&ouml;nnen Parameter &uuml;bernehmen. Daher haben die Methodendefinitionen runde Klammern, die
diese Parameter umgrenzen. In unserem Fall hat die <b>Main</b> Methode keine Parameter (wir wollen ihr nichts &uuml;bergeben) und die <b>WriteLine</b>
Methode aber sehr wohl - den Text der ausgegeben werden soll. Daher k&ouml;nnen wir schreiben:
</p>

<pre style="background='silver';">
Class MainApp
    Public Shared Sub Main()
        System.Console.WriteLine("Hello World")
    End Sub
End Class
</pre>

<p>
Da unsere Sub-Prozedur als Einsprungpunkt dienen soll, mu&szlig; sie allgemein zug&auml;nglich sein (<b>Public</b>) und die
Instanz soll f&uuml;r alle gleich sein. Daher m&uuml;ssen wir zus&auml;tzlich das <b>Shared</b> Schl&uuml;sselwort anf&uuml;hren. Damit 
der Kompiler wei&szlig;, welche <b>WriteLine</b>-Methode wir verwenden wollen, m&uuml;ssen wir angeben wo diese zu finden ist.
Die <b>WriteLine</b>-Methode aus der BCL befindet sich im <b>System</b>-Namespace, der die <b>Console</b> Klasse enth&auml;lt.
Die einzelnen Referenzorte werden mit dem Punktoperator verbunden. Diese Strukturierung der BCL hat vor allem den
Sinn, da&szlig; man unter den vielen Klassen und Methoden auch etwas findet und auch die einzelnen Funktionen logisch trennt
und Doppeldeutigkeiten vermeidet.
</p>

<p>
Einen Namespace kann man sich als eine Art Gruppe vorstellen, die zugeh&ouml;rige (Unter)Namespaces und Klassen enth&auml;lt.
Durch diese Strukturierung kann man sich vorstellen, da&szlig; die Verwendung bzw. Referenzierung von Mitgliedern eines 
Namespaces langwierig werden kann. Deshalb kann man vorab Namespacereferenzen angeben um sich voll-qualifizierte
Pfade (fully qualified paths) jedes mal bei der Anwendung eines Mitgliedes zu ersparen. In VB .NET verwendet man
die <b>Imports</b> Anweisung die logischerweise au&szlig;erhalb der Deklarationen stehen mu&szlig;. Der obige Sourcecode mit 
der zugeh&ouml;rigen Namespace-Referenz:
</p>

<pre style="background='silver';">
Imports System

Class MainApp
    Public Shared Sub Main()
        Console.WriteLine("Hello World")
    End Sub
End Class
</pre>

<p>
Unser einfaches Programm w&auml;re damit fertig und wir k&ouml;nnen es unter <b>HelloWorld.vb</b> speichern. Was noch vor der Ausf&uuml;hrung 
des Programmes fehlt, ist die Kompilierung des Sourcecodes. In einer IDE bzw. einem Editor brauchen Sie meist nur einen 
Button zu klicken und schon erfolgt der Kompiliervorgang. Sollten Sie so ein Werkzeug nicht zur Hand haben und nur das SDK 
installiert haben, mu&szlig; die Datei manuell kompiliert werden. &Ouml;ffnen Sie das Kommandoprompt und wechseln Sie dazu in das 
Verzeichnis wo sich <b>HelloWorld.vb</b> befindet. Nun geben Sie folgende Anweisung an der Eingabeaufforderung ein:
</p>

<pre style="background='silver';">
vbc helloworld.vb /m:MainApp /out:HelloWorld.exe /t:exe
</pre>

<p>
Nach der Best&auml;tigung mit der Enter-Taste wird die Datei kompiliert. Manuelles Kompilieren erfordert immer mehr
"Arbeit" und auch hier m&uuml;ssen neben der Angabe der Quelldatei einige Angaben in Form von Switches gemacht werden:
</p>

<table border="0" cellspacing="2" cellpadding="2">
<tr>
    <th>Switch</th>
    <th>Bedeutung</th>
</tr>
<tr>
    <td>/m oder /main</td>
    <td>Gibt die Klasse mit dem Einsprungpunkt an</td>
</tr>
<tr>
    <td>/out</td>
    <td>Gibt den Namen der zu erstellenden (kompilierten) Datei an</td>
</tr>
<tr>
    <td>/t oder /target</td>
    <td>Teilt dem Kompiler mit welche Art von Applikation erstellt werden soll</td>
</tr>
</table>

<p>
Der Target-Switch bietet folgende M&ouml;glichkeiten an:
</p>

<ul>
<li><b>exe</b>: Konsolenanwendung</li>
<li><b>winexe</b>: Windows-Applikation</li>
<li><b>library</b>: Klassenbibliothek (DLL)</li>
<li><b>module</b>: Modul, das zu einer Assembly hinzugef&uuml;gt werden kann</li>
</ul>

<p>
Wenn man jetzt die erzeugte Executable <b>HelloWorld</b> an der Konsole ausf&uuml;hrt, so erh&auml;lt man die
Zeichenkette "Hello World". Es f&auml;llt auf, da&szlig; nach der Ausgabe der Zeichenkette eine neue Zeile
eingef&uuml;gt wurde. Daher auch der Methodenname "WriteLine", d.h. nach der Zeichenkette wird immer
der Caret in eine neue Zeile gesetzt. Will man dies nicht, so bedient man sich der <b>Write</b>-Methode
der <b>Console</b>-Klasse.
</p>

<p>
Nat&uuml;rlich kann man auch an der Konsole etwas eingeben. Dazu w&auml;re es n&uuml;tzlich wenn man Daten (tempor&auml;r)
speichern k&ouml;nnte.
</p>

<h2>Deklaration und Verwendung von Variablen</h2>

<p>
Variablen sind die einfachsten Datenspeicher. Da Daten unterschiedlicher Natur sein k&ouml;nnen
(Zahl, Zeichenkette, etc.), mu&szlig; man neben der Angabe der Bezeichners einer Variable ihr auch einen 
Typ vergeben, der darauf hinweist um welche Art von Daten es sich handelt. So wie die Typen untereinander
unterschiedlich sind, so unterschiedlich ist auch der G&uuml;ltigkeitsbereich eines Typs und damit auch
sein Speicherbedarf.
</p>

<p>
Die Datentypen im .NET Framework sind zur Common Language Specification (CLS) kompatibel, d.h. sie k&ouml;nnen
in allen Sprachen die sich and die Regeln der CLS halten verwendet werden und haben auch sprach&uuml;bergreifend die
gleichen Eigenschaften (z.B. Wertebereich, signifikante Stellen). Das einzige was sich in den Sprachen &auml;ndert ist
der Bezeichner f&uuml;r den Datentyp (z.B. VB .NET - "Integer", C# - "int"). Die verf&uuml;gbaren Datentypen
des .NET Framework findet man im <b>System</b>-Namespace, welche dort in Strukturen (Structures) nach ihrer Art
eingeteilt sind (z.B. Int16 Structure f&uuml;r 16 bit Integer).
</p>

<p>
Nachfolgend eine Auflistung der m&ouml;glichen Datentypen:
</p>

<table width="625" border="0" cellpadding="2" cellspacing="2">
    <tr>
      <th width="75">
        Datentyp
      </th>
      <th width="400">
        G&uuml;ltigkeitsbereich
      </th>
      <th width="75">
        Speicherbedarf
      </th>
      <th width="75">
        Signifikante Stellen
      </th>
    </tr>
    <tr>
      <td colspan="3" align="left">
        <b>Ganzzahlen</b>
      </td>
    </tr>
    <tr>
      <td valign="top">
        Byte
      </td>
      <td valign="top">
        0 bis 255
      </td>
      <td valign="top">
        8 Bit
      </td>
      <td align="center">3</td>
    </tr>
    <tr>
      <td valign="top">
        SByte
      </td>
      <td valign="top">
        -128 bis 127
      </td>
      <td valign="top">
        8 Bit
      </td>
      <td align="center">3</td>
    </tr>
    <tr>
      <td valign="top">
        Short
      </td>
      <td valign="top">
        -32.768 bis 32.767
      </td>
      <td valign="top">
        16 Bit
      </td>
      <td align="center">5</td>
    </tr>
    <tr>
      <td valign="top">
        UInt16
      </td>
      <td valign="top">
        0 bis 65.535
      </td>
      <td valign="top">
        16 Bit
      </td>
      <td align="center">5</td>
    </tr>
    <tr>
      <td valign="top">
        Integer
      </td>
      <td valign="top">
        -2.147.483.648 bis 2.147.483.647
      </td>
      <td valign="top">
        32 Bit
      </td>
      <td align="center">10</td>
    </tr>
    <tr>
      <td valign="top">
        UInt32
      </td>
      <td valign="top">
        0 bis 4.294.967.295
      </td>
      <td valign="top">
        32 Bit
      </td>
      <td align="center">10</td>
    </tr>
    <tr>
      <td valign="top">
        Long
      </td>
      <td valign="top">
        -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807
      </td>
      <td valign="top">
        64 Bit
      </td>
      <td align="center">19</td>
    </tr>
    <tr>
      <td valign="top">
        UInt64
      </td>
      <td valign="top">
        0 bis 18.446.744.073.709.551.615
      </td>
      <td valign="top">
        64 Bit
      </td>
      <td align="center">19</td>
    </tr>
    <tr>
      <td colspan="3" align="left">
        <b>Gleitkommazahlen</b>
      </td>
    </tr>
    <tr>
      <td valign="top">
        Single
      </td>
      <td valign="top">
        1.5 * 10<sup>-45</sup> bis 3.4 * 10<sup>38</sup>
      </td>
      <td valign="top">
        32 Bit
      </td>
      <td align="center">7</td>
    </tr>
    <tr>
      <td valign="top">
        Double
      </td>
      <td valign="top">
        5.0 * 10<sup>-324</sup> bis 1.7 * 10<sup>308</sup>
      </td>
      <td valign="top">
        64 Bit
      </td>
      <td align="center">15</td>
    </tr>
    <tr>
      <td valign="top">
        Decimal
      </td>
      <td valign="top">
        1.0 * 10<sup>-28</sup> bis 7.9 * 10<sup>28</sup>
      </td>
      <td valign="top">
        128 Bit
      </td>
      <td align="center">29</td>
    </tr>
    <tr>
      <td colspan="3" align="left">
        <b>Datum</b>
      </td>
    </tr>
    <tr>
      <td valign="top">
        Date
      </td>
      <td valign="top">
       0:00:00 am 1. Jannuar, 0001 bis 23:59:59 am 31. Dezember, 9999.
      </td>
      <td valign="top">
        64 Bit
      </td>
      <td align="center">-</td>
    </tr>
    <tr>
      <td colspan="3" align="left">
        <b>Zeichen</b>
      </td>
    </tr>
    <tr>
      <td valign="top">
        Char
      </td>
      <td valign="top">
        0 bis 65535 (1 Unicode Zeichen)
      </td>
      <td valign="top">
        16 Bit
      </td>
      <td align="center">-</td>
    </tr>
    <tr>
      <td valign="top">
        String (Klasse)
      </td>
      <td valign="top">
        0 bis 2 * 10<sup>9</sup> Unicode-Zeichen
      </td>
      <td valign="top">
        Plattformabh&auml;ngig
      </td>
      <td align="center">-</td>
    </tr>
    <tr>
      <td colspan="3" align="left">
        <b>Boolscher Datentyp</b>
      </td>
    </tr>
    <tr>
      <td valign="top">
        Boolean
      </td>
      <td valign="top">
        True oder False
      </td>
      <td valign="top">
        16 Bit
      </td>
      <td align="center">-</td>
    </tr>
 </table>

<p>
Die "signifikanten Stellen" (Pr&auml;zision) geben die M&auml;chtigkeit eines Datentyps an, d.h. desto genauer sind die Nachkommastellen.
Etwas sp&auml;ter in diesem Artikel, bei der "Datentypumwandlung", werden wir sehen, da&szlig; dieser Faktor sehr wohl zu ber&uuml;cksichtigen
ist.
</p>

<p>
Wenn man nun wei&szlig; welche Art von Daten vorliegen, m&ouml;chte man diesen Speicherort auch verwenden. Auf Variablen greift
man mittles Bezeichnern zu. Bezeichnern k&ouml;nnen Sie alle m&ouml;glichen Namen geben. Jedoch sollten einige Regeln eingehalten werden:
</p>

<ul>
<li>Keine Zahlen am Anfang oder nur Zahlen verwenden</li>
<li>Keine Sonderzeichen (!, &ouml;, &amp;, etc.) verwenden</li>
<li>Keine Leerzeichen inzwischen</li>
</ul>

<p>
Um die Lesbarkeit und die Sinnhaftigkeit von Variablen zu erh&ouml;hen, kann man das Pascal-Casing und
zusammengesetzte Worte verwenden, z.B. 
</p>

<pre style="background='silver';">
SummeDerAddition
FlaecheDesRechtecks
</pre>

<p>
Variablen deklariert man prinzipiell mit Hilfe der <b>Dim</b> Anweisung, der Angabe des Bezeichners und des Datentyps:
</p>

<pre style="background='silver';">
Dim Text As String 'Eine Zeichenkette
Dim Wert As Integer 'Eine Ganzzahl
Dim ErgebnisDerWurzel As Double 'Eine Gleitkommazahl
</pre>

<p>
Wie man hier zus&auml;tzlich sehen kann, werden Kommantare mit dem einfachen Anf&uuml;hrungszeichen <b>'</b> angegeben.
Leider gibt es in Visual Basic keine Delimiter f&uuml;r mehrzeilige Kommentare, d.h. jeder Kommentarzeile mu&szlig;
ein <b>'</b> vorangesetzt werden.
</p>

<p>
Variablen werden mit dem "="-Operator Werte zugewiesen. Dabei ist zu beachten, da&szlig; das Komma dem Punkt entspricht
und Zeichenketten innerhalb von doppelten Anf&uuml;hrungszeichen einzugrenzen sind:
</p>

<pre style="background='silver';">
Text = "Das ist eine Zeichenkette"
Wert = 3
ErgebnisDerWurzel = 1.14
</pre>

<p>
Weiters haben Variablen unterschiedliche
G&uuml;ltigkeitsbereiche (Scopes) innerhalb einer Klasse und die Speicherung der Werte erfolgt nur solange der Laufzeit
(Zeit in der das Programm  ausgef&uuml;hrt und aktiv im Speicher ist) des Programms. Beginnen
wir mit dem G&uuml;ltigkeitsbereich. Variablen, die von allen Methoden innerhalb einer Klasse verwendbar sein sollen
hei&szlig;en <b>Membervariablen</b>. Variablen die nur innerhalb einer Methode g&uuml;ltig sein sollen hei&szlig;en <b>Lokale Variablen</b>.
</p>

<p>
Am einfachsten w&auml;re es nat&uuml;rlich alle Variablen als Membervariablen zu definieren damit man sie quasi immer "parat" hat, 
wenn man sie braucht. Dies ist aber weder sinnvoll noch performant. Daher sollte man sich beim Erstellen der
"Einkaufsliste" &uuml;berlegen, welche Variablen man wo ben&ouml;tigt. Membervariablen werden au&szlig;erhalb aller Methodendeklarationen,
also zu Beginn einer Klasse deklariert: 
</p>

<pre style="background='silver';">
Class MyApp

    Dim MyText As String
    Shared Wert As Integer
    
    Public Shared Sub Main()
        ...
    End Sub
End Class
</pre>

<p>
Die Variablen <b>MyText</b> und <b>Wert</b> sind zwar beide "Klassen-global", aber dennoch unterschiedlich in Ihrer Verwendung.
Wenn Sie die oben beschriebene <b>Dim</b>-Anweisung verwenden, erstellen Sie eine Instanzvariable. D.h. Sie m&uuml;ssen
bevor Sie die Variable im Sourcecode verwenden k&ouml;nnen eine Instanz f&uuml;r ein Objekt erstellen. Um von einem Objekt
eine neue Instanz zu erstellen verwenden wir den <b>New</b>-Operator:
</p>

<pre style="background='silver';">
Class MyApp

    Dim MyText As String

    Shared Sub Main()
        Dim MyObj As New MyApp

        MyObj.MyText = "Hello!"
        Console.WriteLine("'MyText' has a value of: " + MyObj.MyText)

    End Sub
End Class
</pre>

<p>
Das bedeutet, jedesmal wenn von dem Objekt eine neue Instanz erzeugt wird, wird eine neue Kopie von der Variable erstellt.
In manchen F&auml;llen ist dies aber unerw&uuml;nscht, d.h. es soll unabh&auml;ngig von der Instanz immer nur eine Kopie von der Variable
im RAM vorhanden sein. Man verwendet dann den <b>Shared</b>-Modifikator statt der <b>Dim</b>-Anweisung:
</p>

<pre style="background='silver';">
Class MyApp

    Shared Wert As Integer
    Shared Sub Main()
        Wert = 5
    End Sub
End Class
</pre>

<p>
Lokale Variablen, deren G&uuml;ltigkeit nur innerhalb einer Methode zutrifft, werden innerhalb einer Methode
deklariert:
</p>

<pre style="background='silver';">
Class MyApp
    
    Public Shared Sub Main()
        Dim MyLocal1 As String
        Dim MeinFlag As Boolean
    End Sub
End Class
</pre>

<p>
Da wir nun die unterschiedlichen Scopes kennen, k&ouml;nnen wir uns dem n&auml;chsten Thema zuwenden:
</p>

<h2>Datentypumwandlungen</h2>

<p>
Um die Wichtigkeit der Datentypumwandlung zu erkennen sehen wir uns den folgenden Code an. Wir wollen eine
Ganzzahl an der Kommandozeile ausgeben:
</p>

<pre style="background='silver';">
Class MyApp

    Shared Wert As Integer
    Shared Sub Main()
        Wert = 5
        Console.WriteLine("'Wert' has the value of: " + Wert.ToString())
    End Sub
End Class
</pre>

<p>
Das "Problem" ist hier, da&szlig; die Variable <b>Wert</b> vom Datentyp <b>Integer</b>, also eine
Ganzzahl, ist. Wenn wir versuchen w&uuml;rden in der <b>WriteLine</b>-Methode einfach nur "Wert" (ohne der Methode
<b>ToString</b>) anzugeben, gibt es ein Problem - wie soll eine Zahl implizit einem String angef&uuml;gt werden? Der Kompiler wei&szlig; 
es jedenfalls nicht, wir m&uuml;ssen ihm dabei helfen.
</p>

<p>
Ohne der <b>ToString</b>-Methode w&uuml;rden wir hier versuchen eine implizite Datentypumwandlung (Implicit Cast) von Integer
auf String durchzuf&uuml;hren. In C++ zum Beispiel h&auml;tte das fatale Folgen. Daher verwenden
die <b>ToString</b>-Methode der <b>Int32</b>-Struktur um das Problem zu beheben.
</p>

<p>
Mit einer impliziten Datentypumwandlung meint man, da&szlig; keine zus&auml;tzlichen Vorkehrungen getroffen werden, also kein zus&auml;tzlicher Syntax
geschrieben wird. Diese ist dann sicher wenn der Ursprungsdatentyp von der M&auml;chtigkeit geringer (weniger
signifikante Stellen) ist als der
Zieldatentyp (Integer auf Double, kein Pr&auml;zisionsverlust). In umgekehrter Reihenfolge, also einer Umwandlung von einem
m&auml;chtigeren Datentyp in einen Typ geringerer M&auml;chtigkeit mu&szlig; man beachten, da&szlig; ein Genauigkeitsverlust durch
die geringere Anzahl von Nachkommastellen (Rundung!) auftritt und bei
&Uuml;berschreitung des G&uuml;ltigkeitsbereiches des Datentyps ein Ausnahmefehler auftritt.
</p>

<p>
Bei expliziten Datentypumwandlungen kann man sich der <b>Convert</b>-Klasse des <b>System</b>-Namespaces bedienen.
Die <b>Convert</b>-Klasse enth&auml;lt alle wichtigen Konvertierungsmethoden.
Explizite Typumwandlung verwenden wir zum Beispiel, wenn wir einen String der als Zahl vorliegt (23) in einen Integer
umwandeln wollen:
</p>

<pre style="background='silver';">
...
    Dim Input As String
    Dim Value As Integer
    Input = "23"
    Value = Convert.ToInt32(Input)
...
</pre>

<p>
Wo dies seine Anwendung finden kann ist bei der Eingabe von Daten an der Kommandozeile:
</p>

<h2>Die Eingabe von Daten an der Kommandozeile</h2>

<p>
Als einfaches Beispiel wollen wir "Hello World" erweitern. Der Benutzer soll nun aufgefordert werden, seinen
Namen einzugeben. Er erh&auml;lt als Ausgabe seinen Namen und wann er das Programm ausgef&uuml;hrt hat. Was brauchen wir hierf&uuml;r? 
Abgesehen von der Namespace-Deklaration, dem Klassenblock und einer Main-Prozedur eine Methode die die Benutzereingabe von der 
Kommandozeile einliest. In der SDK-Dokumentation finden wir in der Console-Klasse die <b>ReadLine</b>-Methode, die Zeichen
von der Komandozeile einliest und somit die Aufgabe erf&uuml;llt. Weiters wollen wir noch wissen wann das "Programm"
aufgerufen wurde. Diese Funktionalit&auml;t (Datum und Uhrzeit des Aufrufs) finden wir in der <b>DateTime</b>-Struktur
des <b>System</b>-Namespaces: die Eigenschaft (Property) <b>Now</b>. Der ben&ouml;tigte Sourcecode k&ouml;nnte so aussehen:
</p>

<pre style="background='silver';">
Imports System

Class MyApp

    Shared CurrentUsrName As String

    Public Shared Sub Main()
        Console.Write("Please enter your name: ")
        CurrentUsrName = Console.ReadLine()
        Console.WriteLine("Hello " + CurrentUsrName + _
		     "! You accessed the program at " + System.DateTime.Now + ".")
    End Sub

End Class
</pre>

<p>
Die Variable f&uuml;r den aktuellen Benutzernamen (<b>CurrentUsrName</b>) habe ich hier global und instanzlos definiert, damit man sie eventuell
weiter verwenden kann und es nur eine Kopie von dieser Variable gibt.
Das Programm ist fertig und wir speichern es unter dem Namen <b>hello.vb</b>. Zum manuellen Kompilieren ist wieder 
folgendes an der Kommandozeile einzugeben:
</p>

<pre style="background='silver';">
vbc hello.vb /m:MyApp /out:Hello.exe /t:exe
</pre>

<p>
Wenn wir nun <b>Hello</b> an der Kommandozeile ausf&uuml;hren und einen Namen eingeben, erhalten wir folgendes Resultat:
</p>

<IMG SRC="/artikel/Bilder/200311/20031128_1.PNG" width="620" height="83" alt="" border="0">

<p>
Wie vorher bei der expliziten Datentypumwandlung erw&auml;hnt, kann es n&ouml;tig sein Zeichenketten die in Form einer
Zahl vorliegen in numerische Datentypen umzuwandeln. Nehmen wir als einfaches Beispiel die Addition von zwei
Zahlen. Der Benutzer soll zwei Zahlen eingeben, die dann addiert werden und das Ergebnis soll ausgegeben werden.
</p>

<p>
Des weiteren wollen wir die
beiden Zahlen gleich direkt beim Aufruf des Programms &uuml;bergeben. Der <b>Main</b>-Methode &uuml;bergeben
wir die Werte as Parameter. Die Werte werden dabei in ein String Array (Datenfeld) abgelegt. Die
genaue Erkl&auml;rung und Verwendung von Arrays folgt in einem der weiteren Artikel. Daher schreiben wir kurz:
</p>

<pre style="background='silver';">
Class AddSamp

    Shared Sub Main(ByVal args() As String)
        Dim A As Double

        A = Convert.ToDouble(args(0)) + Convert.ToDouble(args(1))
        Console.WriteLine("Add-Result: " + A.ToString())
    End Sub
End Class
</pre>

<p>
Dieses Bespiel Speichern wir unter <b>AddSample.vb</b> und kompilieren es. An der Kommandozeile geben wir ein:
</p>

<pre style="background='silver';">
vbc AddSample.vb /m:AddSamp /out:AddSample.exe /t:exe
</pre>

<p>
Nach der Kompilierung k&ouml;nnen wir das Programm gleich ausprobieren. Wichtig dabei ist, da&szlig; wir nicht vergessen
zwei Zahlen, die addiert werden sollen, anzugeben. Wenn wir sie vergessen w&uuml;rden, w&uuml;rden wir einen Ausnahmefehler
erhalten, der besagt, da&szlig; ein Index au&szlig;erhalb des Bereichs liegt (IndexOutOfRangeException). Dies liegt darin begr&uuml;ndet,
da&szlig; das Datenfeld, welches unsere Parameter enth&auml;lt, in diesem Fall leer ist. Rufen wir das Programm mit 
</p>

<pre style="background='silver';">
AddSample 5.2 3.14
</pre>

<p>
auf, erhalten wir an der Kommandozeile die Ausgabe:
</p>

<pre style="background='silver';">
Add-Result is: 8.34
</pre>

<p>
Sie werden sich vielleicht fragen, warum nicht gleich ein Array vom Typ Double in der Parameterliste
der <b>Main</b>-Methode verwendet wurde. Da die <b>Main</b>-Methode der Einsprungpunkt des Programmes
ist darf diese nur eine spezielle Signatur haben. Die Angabe eines Double-Arrays w&uuml;rde dem widersprechen.
Da Kommandozeilen-Programme Parameter &uuml;bernehmen k&ouml;nnen sollen, ist die &Uuml;bergabe eines String-Arrays erlaubt.
Die Verwendung eines Feldes begr&uuml;ndet sich darin, da&szlig; mehrere Parameter &uuml;bergeben werden k&ouml;nnen. Denken Sie
z.B. an den Format-Befehl zum formatieren eines Laufwerks.
</p>

<p>
Die Verwendung der <b>ToDouble</b> Methode ist hier deshalb notwendig damit die Zahlen laut der
Aufgabenstellung algebraisch addiert werden. W&uuml;rden Sie die &uuml;bergebenen Zahlen als Strings belassen,
w&uuml;rde bei &Uuml;bergabe von 2 und 3 das Resultat "23" und nicht richtigerweise "5" sein.
</p>

<p>
Diese Beispiele sind ja einfachst. Leider gibt es Situationen wo das Programm nicht beim ersten Mal kompiliert. Je nach
Art des Fehlers wird man mit mehr oder weniger verst&auml;ndlichen Fehlermeldungen des Kompilers konfrontiert.
</p>

<h2>Wenn einmal Fehler passieren</h2>

<p>
Wenn ein solcher Fall auftritt ist es zwar f&uuml;rs erste frustrierend, aber nicht hoffungslos. Denn man findet s&auml;mtliche
Kompilerfehlermeldungen in der SDK-Dokumentation, die dort genauer erkl&auml;rt werden. Nehmen wir hierzu unser "HelloWorld"
Beispiel her. Was passiert wenn wir z.B. den <b>Shared</b>-Modifikator in der Deklaration der <b>Main</b>-Prozedur
"vergessen" w&uuml;rden? Beim Kompilieren erhalten wir folgenden Fehler:
</p>

<pre style="background='silver';">
vbc : error BC30737: No accessible 'Main' method with an appropriate signature was found in 'MainApp'.
</pre>

<p>
Das ge&uuml;bte Auge erkennt, da&szlig; hier der Kompiler die Signatur des Einsprungpunktes (die <b>Main</b>-Prozedur) in der <b>MainApp</b>-Klasse
nicht finden konnte. Als Anf&auml;nger tut man sich mit der Interpretation dieser Fehlermeldung etwas schwer. In einem solchen
Fall kopieren wir den Fehlercode (<b>BC30737</b>) des Kompilers in die Zwischenablage und &ouml;ffen die SDK-Dokumentation.
Im <b>Suchen</b>-Reiter f&uuml;gen wir in das Eingabefeld den Fehlercode von der Zwischenablage ein. Um die Suche zu 
beschleunigen begrenzen wir im Filterfeld die Suche auf "Visual Basic":
</p>

<IMG SRC="/artikel/Bilder/200311/20031128_2.PNG" width="343" height="289" alt="" border="0">

<p>
Wir erhalten einen exakten Treffer und eine detailierte Anweisung was zu &auml;ndern ist:
</p>

<IMG SRC="/artikel/Bilder/200311/20031128_3.PNG" width="663" height="145" alt="" border="0">

<p>
Obwohl der Fehler einfach war soll diese Demonstration zeigen, da&szlig; die SDK-Dokumentation auch bei der
Fehlersuche ein m&auml;chtiges Hilfsmittel ist.
</p>

<h2>Schlu&szlig;bemerkung</h2>

<p>
Dieser erste Einstiegsartikel sollte Ihnen einen leichten Zugang zu der Vielfalt von VB .NET geben.
Die Demo-Beispiele finden Sie in der Downloadsektion, damit Sie nach der Installation der
Voraussetzungen f&uuml;r VB .NET gleich selbst&auml;ndig Ihre ersten Schritte wagen k&ouml;nnen. In den
folgenden Artikeln zu dieser Serie werden Sie Schritt f&uuml;r Schritt in die Programmierung mit VB.NET
eingef&uuml;hrt werden. Im n&auml;chsten Artikel befassen wir uns mit den Operatoren, Kontrollstrukturen und
Schleifen. 
</p>

<p><strong>This printed page brought to you by <a href="http://www.alphasierrapapa.com/">AlphaSierraPapa</a></strong></p>
<h2>Download des Codes</h2>
<p><a href="../Code/20031128.zip">Klicken Sie hier</a>, um den Download zu starten.<br><SPAN class="content">http://www.aspheute.com/code/20031128.zip</span></p>
<h2>Verwandte Artikel</h2>
<p>
<a href="../artikel/20001102.htm">Datenbankzugriff mittels ADO.NET</a><br>
<SPAN class="content">http:/www.aspheute.com/artikel/20001102.htm</span><br>
<a href="../artikel/20000808.htm">Einf&uuml;hrung in ASP.NET Web Forms</a><br>
<SPAN class="content">http:/www.aspheute.com/artikel/20000808.htm</span><br>
<a href="../artikel/20011010.htm">Sprachenintegration in .NET</a><br>
<SPAN class="content">http:/www.aspheute.com/artikel/20011010.htm</span><br>

</p>
<h2>Links zu anderen Sites</h2>
<p>
<a target="_blank" href="/REMOVED/3w_link.asp?3wsite=http%3A%2F%2Fwww%2Edotnetgerman%2Ecom%2Flinks%2Fdl%5Fdotnetsdk%2Easp">.NET Framework Software Development Kit (SDK)</a><br>
<SPAN class="content">http://www.dotnetgerman.com/links/dl_dotnetsdk.asp</span><br>
<a target="_blank" href="/REMOVED/3w_link.asp?3wsite=http%3A%2F%2Fwww%2Eicsharpcode%2Enet%2FOpenSource%2FSD%2F">SharpDevelop</a><br>
<SPAN class="content">http://www.icsharpcode.net/OpenSource/SD/</span><br>
<a target="_blank" href="/REMOVED/3w_link.asp?3wsite=http%3A%2F%2Fmsdn%2Emicrosoft%2Ecom%2Fvstudio%2F">Visual Studio .NET</a><br>
<SPAN class="content">http://msdn.microsoft.com/vstudio/</span><br>

</p>

&nbsp;<P>
<center>

</center>

<center>
<p class="content">
&copy;2000-2006 <A HREF="../service/copyright.htm" title="Copyright Informationen">AspHeute.com</A><br>
Alle Rechte vorbehalten. Der Inhalt dieser Seiten ist urheberrechtlich gesch&uuml;tzt.<br>
Eine &Uuml;bernahme von Texten (auch nur auszugsweise) oder Graphiken bedarf unserer schriftlichen Zustimmung.
<hr>
</p>
</center>

</td>
</tr><!--Tabelle aussen, 2/2-->
</table><!--Tabelle aussen-->
</div>

</BODY>
</HTML>
