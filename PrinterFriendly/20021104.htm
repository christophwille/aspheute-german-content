<HTML>
<HEAD>
<TITLE>Tee Off! Die Zweite</TITLE>
<META HTTP-EQUIV="content-type: text/html; charset= ISO-8859-1">
<META HTTP-EQUIV="Content-Language" CONTENT="DE">
<META NAME="robots" CONTENT="FOLLOW,INDEX">
<META NAME="generator" CONTENT="Xitra Site Publishing">
<meta name="Author" content="webmaster@aspheute.com">

<META NAME="revisit-after" CONTENT="21 days">
<META NAME="copyright" CONTENT="(c) 2000-2006. Alle Rechte vorbehalten. Der Inhalt dieser Seiten ist urheberrechtlich geschützt.">
<META HTTP-EQUIV="expires" CONTENT="1999-03-30T00:00:00+00:00"> 
<META HTTP-EQUIV="Pragma" CONTENT="no-cache">
<META HTTP-EQUIV="Cache-Control" CONTENT="no-store">

<meta http-equiv="Description" name="Description" content="Nach dem Erfolg des ersten ASP Golfturniers ging es mit folgender Aufgabenstellung in die zweite Runde: Eine Wortliste ist gegeben. Alle in ihr vorkommenden Anagramme sollen gruppiert werden.">
<meta http-equiv="Keywords" name="Keywords" content="ASP,Active Server Pages,IIS,Internet Information Server,PWS,Personal Web Server,ADO,Golf,Minigolf,Anagram,Anagramgruppen,Golfturnier,Fairway,Bunker,Drive,Abschlag,Aufgabe,Aufgabenstellung,Wortliste,ASP">
<link rel="stylesheet" href="../includes/default.css">
</HEAD>
<BODY BGCOLOR="#ffffff" >


<div style="border-bottom: solid 5px white;">
<div class="DotNetGermanCommunityBar">
    <a href="http://www.glengamoi.com">Glengamoi (Forum)</a> &middot;
    <a href="http://www.aspheute.com/" style="font-weight: bold">AspHeute</a> &middot;
    <a href="http://dotnetheute.com/">.NET Heute (RSS-Suche)</a> &middot;
    <a href="http://aspxfiles.com/">AspxFiles (Wiki)</a> &middot;
    <a href="http://blogs.dotnetgerman.com/">.NET Blogs</a>
</div>
</div>


<H1>Tee Off! Die Zweite</H1>
<p>
Geschrieben von: <a href="../autoren/bernhardspuida.htm">Bernhard Spuida</a><br>
Kategorie: <a href="../kategorien/Tee%20Off.htm">Tee Off</a><br>
<SCRIPT src="/service/artikelbewertung.asp?Artikel=20021104"></SCRIPT>
</p>


<p><strong>This printed page brought to you by <a href="http://www.alphasierrapapa.com/">AlphaSierraPapa</a></strong></p><p>
Nach dem Erfolg des ersten ASP Golfturniers ging es mit folgender Aufgabenstellung in die zweite Runde:
Eine Wortliste ist gegeben. Alle in ihr vorkommenden Anagramme sollen
gruppiert werden. Anagramgruppen werden im Beispiel zur Verdeutlichung
durch einen Strich voneinander abgetrennt.
Gro&szlig;/Kleinschreibung mu&szlig; nicht ber&uuml;cksichtigt werden. Die &Uuml;bergabe an
das Testskript folgt der im ersten Minigolf - d.h. keine eigenen
Leseroutinen in das Golfskript einbauen, wird vom Testskript gemacht.
</p>
<p>
<b>Beispiel Eingabe:</b><br>
alle albern Albert deren ella elle elise else gerne green lagen leise
nagel nager neger neiger Reden regen reggae reigen
</p>
<p>
<b>Liefert als Ergebnis:</b><br>
gerne green neger regen | alle ella | deren reden | elise leise | lagen
nagel | neiger reigen | albern | albert | elle | else | nager | reggae
</p>
<p>
Die eigentliche Wortliste ist nat&uuml;rlich l&auml;nger. Sortierung ist nicht notwendig. Dubletten werden nicht 
auftreten. Die Eingabe und Ausgabe der Werte erfolgt &uuml;ber ein Array mit einem Wort pro Element als Input, ein 
Array of Arrays als Output, wobei die Subarrays jeweils einer Anagrammgruppe entsprechen. Die Trennstriche aus dem 
obigen Beispiel sind *nicht* mitzu&uuml;bergeben, sie dienen nur zur besseren Darstellung im Beispiel!
</p>
<p>
<b>Input:</b><br>
Application("input")=Array("alle","albern","Albert",...,"reigen")<br>
<b>Output:</b><br>
Application("output")=Array( Array("gerne","green","neger","regen"),
Array("alle","ella"), ... )
</p>
<p>
Die Testliste ist entnommen aus <a href="http://download.sourceforge.net/wordlist/12dicts-3.0.zip" target="_blank">http://download.sourceforge.net/wordlist/12dicts-3.0.zip</a>
Es handelt sich um eine Untermenge der Worte in der Datei <i>6of12.txt</i>. F&uuml;r eigene Tests kann jeder sich die 
entsprechenden Dateien selbst holen. Zu beachten ist, da&szlig; die Worte nur aus a-z bestehen und keine Sonder- oder Leerzeichen 
enthalten, ebenso keine Umlaute.
</p>

<h2>Die Resultate</h2>
<p>
Die Herausforderung wurde mit Begeisterung angenommen. Erfreulich war auch, da&szlig; einige neue Golfer dazukamen. Herzlich 
willkommen am Platz!
</p>
<p>
Nun zum Leaderboard (<a href="http://www.aspgerman.com/golf/archiv.asp?action=leader&id=1#data" target="_blank">Details</a>):
</p>

<ol>
<li>Roman Pittroff - 221 Schl&auml;ge</li>
<li>Michael Schmidt - 225</li>
<li>Alexander Veit - 233</li>
<li>Markus Oestreicher - 240</li>
<li>Ingo H&ouml;ller - 247</li>
<li>Wolfgang Kluge - 259</li>
<li>Gerhard Buchner - 262</li>
<li>Nils Kochan - 276</li>
<li>Andreas Roth - 279</li>
<li>Johann Engbers - 280</li>
<li>Ralf Schoch - 308</li>
</ol>

<p>
Im Bunker landeten trotz verzweifelter Schaufelaktivit&auml;ten: Thorsten Eiben und Michael Guder. Kopf hoch - n&auml;chstes 
Mal wirds wieder. Keep on Golfing!
</p>
<p>
Das Turnier war spannend vom Anfang bis zum Ende: die erste g&uuml;ltige L&ouml;sung lag bei 446 Schl&auml;gen, bis zum 
Turnierende wurde die Aufgabe bis auf 221 Schl&auml;ge heruntergegolft. Eine beachtliche Leistung! Es gab auch 
zwischenzeitlich Tie-breaks, die zu weiteren &uuml;bermenschlichen Anstrengungen f&uuml;hrten.
</p>
<p>
In diesem Turnier wurde auch eine Neuerung eingef&uuml;hrt: ein 
<a href="http://www.aspgerman.com/golf../default.htm" target="_blank">Online-Golfplatz</a> wo die Spieler ihre L&ouml;sungen 
automatisch an die Schiedsrichter einreichen k&ouml;nnen und ein Leaderboard zur Verf&uuml;gung steht. Der Tester wurde auch 
dieses mal wieder von <a href="../autoren/claudiusceteras.htm">Claudius Ceteras</a> 
programmiert - herzlichen Dank, Claudius! Insgesamt kamen sechs verschiedene Testdatens&auml;tze zum Einsatz um verschiedene 
Algorithmen auszuscheiden die prinzipbedingt unvollst&auml;ndige L&ouml;sungen erzeugen.
</p>
<p>
Genug der Vorrede, auf zum Abschlag: da es dieses mal einige interessante Ans&auml;tze gab, die leider nicht auf den vorderen 
Pl&auml;tzen landeten, werden wir dieses mal nicht die ersten drei Pl&auml;tze betrachten.
</p>

<h3>Thorsten Eiben</h3>
<p>
Thorsten blieb zwar im Bunker h&auml;ngen, aber sein Ansatz verdient Beachtung. In seinen Worten:
</p>
<p>
Hallo Sportsfreunde:
</p>
<p>
Hier zur allgemeinen Erheiterung mein bester Bunkerversuch. Sicherlich nicht geeignet, um zuk&uuml;nftigen Golfern den Weg zu 
zeigen, aber immerhin ein anderer Ansatz und vielleicht kann mich ja mal jemand aufkl&auml;ren warum
der Abschlag im Sand landete.
</p>

<pre style="background='silver';">
&lt;%set z=Application:a=z("Input")
for each c in a:v=len(c)
if v&gt;0then
s=c
for j=0 to ubound(a)
h=a(j)
if v=len(h) and strComp(c,h)&lt;&gt;0then
for q=1 to len(c)
r=mid(c,q,1):h=replace(h,r,"",1,1):next
if len(h)=0 then s=s+","+a(j):a(j)=""
end if:next:u=u+s+" "
end if:next:o=split(u)
for p=0 to ubound(o):o(p)=split(o(p),","):next
z("Output")=o
%&gt;
</pre>

<p>
Die Idee war beim zu testenden Wort den jeweils aktuellen Buchstaben durch ein Leerzeichen zu ersetzen - falls am Ende ein 
leerer String rauskommt ist's ein Anagramm. Vom Hashalgo hatte ich mich nach Claudius Warnung verabschiedet. H&auml;tte man mit 
dem Dictionary-Ansatz auch bestimmt noch unter 300 schrumpfen k&ouml;nnen...
</p>
<p>
<i>Anmerkungen dazu: Die Bemerkung mit den Hashes bezieht sich darauf da&szlig; multiplikative und additive Hashes 
unvollst&auml;ndige L&ouml;sungen liefern. Der Fehler war letzten Endes ein leeres Element am Ende des Arrays. Au&szlig;erdem lassen 
sich hier und da ein paar Bytes sparen wenn man die Techniken anwendet, die im <a href="../artikel/20020930.htm">Tee Off!</a> des ersten Turniers vorgestellt 
wurden und auch in der n&auml;chsten vorgestellten L&ouml;sung verwendet werden (Tip: For-Schleifen n&auml;her anschauen). 
Trotz Bunkerlandung ein interessanter Ansatz. Keep on golfing, Thorsten!</i>
</p>

<h3>Andreas Roth</h3>
<p>
Andreas kam leider nicht sonderlich weit nach vorne, aber seine letztg&uuml;ltige L&ouml;sung kommt den urspr&uuml;nglichen 
Vorstellungen der Schiris recht nahe - sowohl was Ansatz als auch L&auml;nge betrifft, au&szlig;erdem stellt er auch noch einige 
andere L&ouml;sungsversuche vor, die auch andere Spieler verwendeten, daher werden seine L&ouml;sungen stellvertretend 
pr&auml;sentiert:
</p>

<pre style="background='silver';">
&lt;%Set V=Application
A=V("input")
Set w=CreateObject("scripting.dictionary")
'(1)
For B=0To Ubound(A)
E=A(B)
'(2)
For C=9To 122
For D=1To len(E)
If c=asc(mid(e,d))Then Z=Z&amp;chr(c)
Next
Next
'(3)
w(Z)=w(Z)&amp;" "&amp;E
Z=""
Next
'(4)
For Each K in w.keys
W(K)=Split(trim(W(K)))
Next
('5)
V("output")=w.Items%&gt;
</pre>

<p>
Eigentlich auf Anregungen aus einem Gespr&auml;ch mit Alex Veit programmiert. Das ganze ist sehr einfach zu verstehen.
Ein Scripting Dictionary wird instanziert, dann alle Inhalte einmal in einer Schleife durchgegangen (1), wobei
jeweils ein String erzeugt wird, in dem die Buchstaben sortiert sind (2). Der wird als Schl&uuml;ssel genommen und der 
Pr&uuml;fling dem Dictionary Eintrag mit diesem Schl&uuml;ssel zugewiesen(3). Anschlie&szlig;end werden die Dictionary
Eintr&auml;ge noch mit Split zu einem Array umgewandelt (4). Die Dictionary Eigenschaft Items gibt dann das gew&uuml;nschte 
Array an Output weiter (5).
</p>
<p>
Die Stringverkettung und anschlie&szlig;ende Umwandlung sowie weitere kleine Tricks sind beim letzten Golf gut beschrieben worden.
Nach der Einsendung dieses Scripts letzten Donnerstag konnte ich mich leider zeitlich nicht mehr dem Golf widmen.
</p>
<p>
Hier m&ouml;chte ich noch ein paar von den ersten Versuchen zeigen, die ja vielleicht auch ganz interessant sind.
Hier mein erster (funktionierender) Ansatz:
</p>

<pre style="background='silver';">
&lt;%Set V=Application
A=V("input")
G=vbCr
H=Ubound(A)
O=""""
'(1)
P="Array("
For B=0To H
C=A(B)
If C&lt;&gt;G Then
Z=Z&amp;","&amp;P&amp;O&amp;C
A(B)=G
For I=0To H
J=A(I)
N=Len(C)
Q=Len(J)
If J&lt;&gt;G AND N=Q Then
K=C
M=0
For D=1To Q
'(2)
L=instr(K,mid(J,D,1))
If L&lt;&gt;0 Then K=mid(K,1,L-1)&amp;mid(K,L+1):M=M+1
Next
'(zu 1)
If M=N Then Z=Z&amp;""","""&amp;J:A(I)=G
End If
Next
'(zu 1)
Z=Z&amp;""")"
End If
Next
'(Zu 1)
Execute "V(""output"")="&amp;P&amp;mid(Z,2)&amp;")"%&gt;
</pre>

<p>
(1): Ich baue das Array im Array als Befehlsstring auf, den ich erst am Ende mit dem Execute Befehl ausf&uuml;hre zB: Execute
"V(""output"")=Array(Array("aae",aea"),Array(""abb"",""bab""))" (2): Ich habe 2 Schleifen die den Code durchgehen. Wird in der 
ersten Schleife ein Wort erreicht, das noch nicht getestet wurde, wechselt es in die 2. Schleife. Dort wird das Wort in einen 
String kopiert und jedes, nicht als gebraucht markierte Wort wird verglichen, indem aus dem kopierten String jeder gefundene 
Buchstabe entfernt wird. Ist der String anschlie&szlig;end leer und die Worte waren gleich lang, handelt es sich um ein Anagramm.
Benutzte Worte werden markiert, indem ihnen Buchstabe O zugewiesen wird.
</p>
<p>
Da hier insbesondere die Erzeugung der Arrays viel Raum einnimmt, hab ichs doch mal mit einer klassischen Variante versucht
(hier mit zu ungenauem Hashalgo bei (1), der wie ich mittlerweile wei&szlig;, mit ^4 funktioniert h&auml;tte):
</p>

<pre style="background='silver';">
&lt;%Set V=Application
A=V("input")
H=Ubound(A)
O=" "
For B=0To H
C=A(B)
If C&lt;&gt;O Then
For I=0To H
J=A(I)
N=Len(C)
If N=Len(J) Then
K=0
L=0
'(1)
For D=1To N
L=L+asc(mid(J,D))^2
K=K+asc(mid(C,D))^2
Next
If L=K Then Z=Z&amp;O&amp;J:A(I)=O
End If
Next
'(2)
Redim Preserve Y(U)
Y(U)=split(trim(Z))
U=U+1
Z=O
End If
Next
V("output")=Y%&gt;
</pre>

<p>
(1) Z&auml;hlt die quadrierten Ascii Codes zusammen, um somit einen Vergleichswert bei gleichen Buchstaben eines Strings zu 
erhalten. (2) Hier vergr&ouml;&szlig;ere ich das sp&auml;tere Ausgabe-Array immer wieder mit Redim Preserve.
</p>
<p>
Das h&auml;tte dann meine funktionierende Eingabe sein k&ouml;nnen, wenn ich nicht wegen Claudius Ausschlu&szlig; von addierenden 
Hashes diesen Weg aufgegeben h&auml;tte.
</p>
<p>
<i>Anmerkungen: Ein wunderbares Beispiel f&uuml;r Evolution am Werk. Was die selbst geschnitzten Hashes angeht, so finden 
sich bei den meisten Ans&auml;tzen in diesem Turnier Schwachpunkte, die Erkl&auml;rung stammt von Alexander Veit:</i>
</p>

<p>
Das Problem bei diesen arithmetischen Hashes erkl&auml;rt sich einfach mit Hilfe des Schubfach-Prinzips:
Der Werteraum der Zahldatentypen in VB ist endlich, es gibt aber unendlich viele Strings. Also werden mehrere Strings auf 
denselben Hash abgebildet. Das Problem h&auml;tte man nicht, wenn es in VB Arithmetik mit beliebiger
Genauigkeit g&auml;be. Dann k&ouml;nnte man z.B. eine Zahl N finden soda&szlig;:
</p>

<pre style="background='silver';">
function hash(s)
        hash = 1
        for i = 1 to len(s)
                hash = hash * (N + asc(mid(s, i)))
        next
end function
</pre>

<p>
genau f&uuml;r Anagramme denselben Wert h&auml;tte.
</p>

<p><i>Danke, Alex!</i></p>

<h3>Markus Oestreicher</h3>
<p>
Wie wir gleich am Beispiel von Markus sehen werden, ist auch kreative Fehlerbehandlung ein interessanter Ansatz:
</p>

<pre style="background='silver';">
&lt;%
 '(1)
 set d=createobject("scripting.dictionary")
 set f=application
 y=f("input")

 for j=0to ubound(y)
  w=y(j)
  x=1
  '(2)
  for i=1to len(w)
   x=x+asc(mid(w,i))^4
  next

  '(3)
  on error resume next
  m=""
  m=join(d(x))

  ' (4)
  d(x)=split(trim(m&amp;" "&amp;w))
 next
 f("output")=d.items
%&gt;
</pre>

<p>
1) Auf diese Zeile bin ich stinkig. 42 Bytes, die sich nicht mehr zusammenschrumpfen lassen. Aber wie bereits gesagt,
verh&auml;lt sich das Dictionary sp&auml;ter viel handlicher als ein Array...
</p>
<p>
2) Das aktuelle Wort befindet sich in "w". Ich bilde eine Summe aller Ascii-Codes, die sp&auml;ter als gemeinsamer Nenner
aller Anagramme sowie Index in meinem Dictionary dient.</p>
<p>
3) Die Fehlerbehandlung wird abgeschaltet, damit die join()-Funktion keinen Fehler auswerfen kann. Unelegant, aber
ein paar Bytes k&uuml;rzer als ein "if isempty(...) else ... "
</p>
<p>
4) Das Ergebnis wird wieder zusammengef&uuml;gt und in das Dictionary zur&uuml;ckgeschrieben. Das Dictionary-Objekt macht
uns durch das Array "Items" den letzten Schritt sehr einfach.
</p>
<p>
<i>Anmerkungen dazu: wer bremst hat Angst... Gut gegolft! Aber unser Sieger zeigt uns wie man auch ohne Fehlertricks zum 
Green kommt.</i>
</p>

<h3>Roman Pittroff</h3>
<p>
Roman hat das unm&ouml;gliche geschafft: eine unglaublich kurze, elegante L&ouml;sung die wieder einmal neue 'Features' von 
VBscript aufzeigt:
</p>

<pre style="background='silver';">
&lt;%
Set d=CreateObject("Scripting.Dictionary")
set a=Application
i=a("input")
for each e in i
        s=n
        for y=97to 122
                s=s&amp;ubound(split(e,chr(y)))
        next
        if d.exists(s)then e=join(d(s))&amp;" "&amp;e
        d(s)=split(e)
        next
a("output")=d.items
%&gt;
</pre>

<p>
Den Anfang hatten wir beim ersten Golfen schon:
</p>

<pre>
2..set a=Application
3. i=a("input")
</pre>

<p>
Mit [for each] spare ich mir das UBound() und die Klammern um auf das Array zuzugreifen
</p>

<pre>
4. for each e in i
</pre>

<p>
Mein Grundgedanke war wie man die Werte am besten vergleichen kann ohne zweimal die Arrayliste mit einem Loop durchzugehen.
Die Folgerung war einen Hash zu bilden der Anagrame erkennt und mit dem man die Strings vergleichen kann.
</p>

<pre>
5. for y=97to 122
6.         s=s&amp;ubound(split(e,chr(y)))
7. next
</pre>

<p>
a.) Loop durch das Character Set von a chr(97) zu z chr(122)<br>
b.) Anzahl der Zeichen in dem String<br>
<br>
Ergebnis fuer "abbeggg"<br>
0000000000000000000000000<br>
1200103000000000000000000<br>
</p>

<p>
Ok f&uuml;rs golfen habe ich nat&uuml;rlich das ;-)
</p>

<pre>
5. for y=97to 122
</pre>

<p>
Die Ausgabe erfolgt mit Hilfe eines Dictionary. Ich habe mir am Anfang zwar Gedanken &uuml;ber den Overhead von 36 Zeichen
gemacht, aber die Vorteile beim Array-Handling und Vergleich des Hashes lagen einfach auf der Hand.
</p>

<pre>
1. d=CreateObject("Scripting.Dictionary")
</pre>

<p>
Hier &uuml;berpr&uuml;fen wir: gibt es den Key schon? Wenn ja, String an das Array anh&auml;ngen
</p>

<pre>
8. if d.exists(s)then e=join(d(s))&amp;" "&amp;e
</pre>

<p>
Hier den String als Array in das Dictionary schreiben
</p>

<pre>
9. d(s)=split(e)
</pre>

<p>
Und nun das Dictionary als Array &uuml;bergeben.
</p>

<pre>
12. a("output")=d.items
</pre>

<p>
<i>Anmerkungen: Gratulation! Meisterhaftes Sparen an Leerzeichen, gekoppelt mit einem eleganten L&ouml;sungsansatz und einer 
originellen Verwendung von 'for each' in Zeile 4... Was soll man da noch sagen? Als Schiri kann man sich da nur noch ins 
Klubhaus an die Bar verziehen und sich eine neue (teuflische) Aufgabe f&uuml;r das n&auml;chste Turnier ausdenken.</i>
</p>

<h2>Schlu&szlig;bemerkung</h2>
<p>
So, liebe Golffreunde, das wars f&uuml;r heute vom Golfplatz. Schalten sie sich wieder ein wenn sie das n&auml;chste mal 
'Fore!' h&ouml;ren.
</p>

<p><strong>This printed page brought to you by <a href="http://www.alphasierrapapa.com/">AlphaSierraPapa</a></strong></p><h2>Verwandte Artikel</h2>
<p>
<a href="../artikel/20021202.htm">3. Loch - Dr. Evils Qualit&auml;tskontrolle</a><br>
<SPAN class="content">http:/www.aspheute.com/artikel/20021202.htm</span><br>
<a href="../artikel/20020930.htm">Tee Off - Das erste ASP Golf Turnier</a><br>
<SPAN class="content">http:/www.aspheute.com/artikel/20020930.htm</span><br>
<a href="../artikel/20031222.htm">Tee Off! Wolpertinger Genome Project</a><br>
<SPAN class="content">http:/www.aspheute.com/artikel/20031222.htm</span><br>
<a href="../artikel/20030115.htm">Tee Off! Zahlen, W&ouml;rter, Zahlw&ouml;rter</a><br>
<SPAN class="content">http:/www.aspheute.com/artikel/20030115.htm</span><br>

</p>
<h2>Links zu anderen Sites</h2>
<p>
<a target="_blank" href="/REMOVED/3w_link.asp?3wsite=http%3A%2F%2Fwww%2Easpgerman%2Ecom%2Fgolf%2Farchiv%2Easp%3Faction%3Dleader%26id%3D1%23data">Leaderboard 2. ASP Golf Turnier</a><br>
<SPAN class="content">http://www.aspgerman.com/golf/archiv.asp?action=leader&id=1#data</span><br>
<a target="_blank" href="/REMOVED/3w_link.asp?3wsite=http%3A%2F%2Fwww%2Easpgerman%2Ecom%2Fgolf%2Fdefault%2Easp">Online Golfplatz</a><br>
<SPAN class="content">http://www.aspgerman.com/golf../default.htm</span><br>

</p>

&nbsp;<P>
<center>

</center>

<center>
<p class="content">
&copy;2000-2006 <A HREF="../service/copyright.htm" title="Copyright Informationen">AspHeute.com</A><br>
Alle Rechte vorbehalten. Der Inhalt dieser Seiten ist urheberrechtlich gesch&uuml;tzt.<br>
Eine &Uuml;bernahme von Texten (auch nur auszugsweise) oder Graphiken bedarf unserer schriftlichen Zustimmung.
<hr>
</p>
</center>

</td>
</tr><!--Tabelle aussen, 2/2-->
</table><!--Tabelle aussen-->
</div>

</BODY>
</HTML>
